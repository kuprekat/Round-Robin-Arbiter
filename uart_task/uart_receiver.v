// **********************
// *модуль uart_receiver*
// **********************
// Модуль приёма сообщения по протоколу UART.
// 
// Требует подключения модулей:
// * uart_deserializer
// * clock_divider
// * shift_register_l
// 
// = Входы =
// [ бит] rx   : провод данных.
// [ бит] clock: такт.
// [ бит] reset: асинхронный сброс.
//
// = Выходы =
// [шина] data [W]: принятые данные.
// [ бит] valid   : корректность принятых данных.
// [ бит] busy    : передатчик занят.
//
// = Параметры =
// [integer] IF        [50000000]: частота тактового сигнала схемы.
// [integer] UF        [9600    ]: частота приёма сообщения по протоколу UART.
// [integer] W         [8       ]: число битов в передаваемом сообщении.
// [integer] Mode      [0       ]: порядок передачи битов сообщения:
//   Mode == 0: от младшего к старшему;
//   Mode == 1: от старшего к младшему.
// [integer] Parity    [0       ]: вид проверки чётности:
//   Parity == 0: проверки чётности нет;
//   Parity == 1: прямая проверка чётности;
//   Parity == 2: обратная проверка чётности.
// [integer] Precision [1       ]:
//   Один такт на частоте протокола UART делится на 2+Precision подтактов.
//   При приёме данных считывается значение между подтактами, наиболее близкое к середине такта.
//   Чем выше Precision, тем больше устойчивость к погрешности фактической частоты UART.
// 
// = Ограничения на параметры =
// IF >= UF*(2+Precision) >= 1
// W >= 1
// Mode in {0, 1}
// Parity in {0, 1, 2}
// Precision >= 1
//
// = Функционирование =
// До асинхронного сброса значения выходных сигналов не определены.
// Далее описывается функционирование модуля после сброса.
// 
// Модуль может находиться в двух режимах:
// * режим ожидания;
// * режим приёма.
// После сброса модуль переходит в режим ожидания.
// 
// В режиме приёма:
// * busy == 1;
// * сигнал valid опускается, если был поднят;
// * с провода rx принимается сообщение, посланное по протоколу UART согласно выставленным параметрам, на частоте UF/IF * freq, где freq - частота тактового сигнала на входе clock;
// * если сообщение принято корректно (пройдена проверка чётности, на нужных местах найдены начинающий бит и первый завершающий бит - start bit, stop bit), то по выходе из режима приёма в data выдаётся принятое сообщение и сигнал valid поднимается;
// * если сообщение принято некорректно, то по выходе из режима приёма в data выдаётся "мусор", и сигнал valid остаётся опущенным.
// 
// В режиме ожидания:
// * busy == 0;
// * значения data и valid, полученные по выходе из последнего режима приёма, сохраняются;
// * если не было ни одного режима приёма, то data == xx..x и valid == 0.
// 
// Приём сообщения и переход в соответствующий режим устроены следующим образом:
// 
// * Внутри модуля генерируется замедленный тактовый сигнал (далее обозначаемый словом uclock).
//   Отношение частоты сигнала uclock к частоте тактового сигнала clock равно UF*(2+Precision)/IF.
//   В частности, если сигнал clock имеет частоту IF Гц, то сигнал uclock имеет частоту UF*(2+Precision) Гц - в 2+Precision раз больше, чем частота UART, указанная в параметре.
// 
// * Модуль постоянно считывает значение на проводе rx по передним фронтам сигнала uclock.
//   При обнаружении значения 0 на проводе rx в режиме ожидания модуль переходит в режим приёма.
// 
// * Фронты uclock, начиная с того, на котором произошёл переход в режим приёма, делятся на группы: в одну группу входят 2+Precision подряд идущих фронта.
//   С провода rx последовательно считываются значения по средним фронтам групп, в случае корректной передачи - такие:
//   * start, m[1], ..., m[W], stop, если Parity == 0;
//   * start, m[1], ..., m[W], parity, stop, если Parity != 0.
// 
// * Если start == 1, то приём немедленно завершается без чтения дальнейших битов, сообщение принято некорректно (начинающий бит недостаточно продолжителен).
//   Иначе приём продолжается, читаются следующие значения.
// * Значения m[1], ..., m[W], когда прочитаны, неизменно выводятся в data и располагаются от младшего бита к старшему, если Mode == 0, и от старшего бита к младшему, если Mode == 1.
// * Если Parity == 1 и parity отлично от суммы по модулю 2 значений m[1], ..., m[W], то приём немедленно завершается без чтения значения stop, сообщение принято некорректно (не пройдена проверка чётности), иначе читается значение stop.
// * Если Parity == 2 и parity равно сумме по модулю 2 значений m[1], ..., m[W], то приём немедленно завершается без чтения значения stop, сообщение принято некорректно (не пройдена проверка чётности), иначе читается значение stop.
// * После чтения значения stop приём немедленно завершается.
//   Если stop == 1, то поднимается сигнал valid - сообщение принято корректно.
//   Иначе сигнал valid не поднимается - сообщение принято некорректно (не найден завершающий бит).
// 
// = Модуль написал =
// Владислав Подымов
// 2018
// e-mail: valdus@yandex.ru
module uart_receiver(rx, clock, reset, data, valid, busy);
  parameter integer IF = 50000000;
  parameter integer UF = 9600;
  parameter integer W = 8;
  parameter integer Mode = 0; // 0: lsb -> msb; 1: msb -> lsb
  parameter integer Parity = 0; // 0 = none; 1 = odd; 2 = even
  parameter integer Precision = 1; // 2+this subtacts are contained in one uart tact; the middle tact is where the value is read
  input rx, clock, reset;
  output [W-1:0] data;
  output valid, busy;
  
  wire uart_clock;
  
  clock_divider #(
    .IF(IF),
    .OF(UF*(Precision+2))
  )
  _divider(
    .in(clock),
    .reset(reset),
    .out(uart_clock)
  );
  
  uart_deserializer #(
    .W(W),
    .Mode(Mode),
    .Parity(Parity),
    .Precision(Precision)
  )
  _deserializer(
    .rx(rx),
    .clock(uart_clock),
    .reset(reset),
    .data(data),
    .valid(valid),
    .busy(busy)
  );
endmodule
